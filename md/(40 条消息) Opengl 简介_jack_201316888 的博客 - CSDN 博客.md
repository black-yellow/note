> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/u010451780/article/details/121732605)

**OpenGL（英语：Open Graphics Library，译名：开放图形库或者 “开放式图形库”）**是用于渲染 2D、3D [矢量图](https://so.csdn.net/so/search?q=%E7%9F%A2%E9%87%8F%E5%9B%BE&spm=1001.2101.3001.7020)形的跨语言、跨平台的应用程序编程接口（API）。这个接口由近 350 个不同的函数调用组成，用来绘制从简单的图形比特到复杂的三维景象。而另一种程序接口系统是仅用于 Microsoft Windows 上的 Direct3D。OpenGL 常用于 CAD、虚拟现实、科学可视化程序和电子游戏开发。

[OpenGL](https://so.csdn.net/so/search?q=OpenGL&spm=1001.2101.3001.7020) 被设计为**只有输出的**，所以它只提供渲染功能。核心 [API](https://so.csdn.net/so/search?q=API&spm=1001.2101.3001.7020) 没有窗口系统、音频、打印、键盘 / 鼠标或其他输入设备的概念。虽然这一开始看起来像是一种限制，但它允许进行渲染的代码完全独立于他运行的操作系统，**允许跨平台开发**。

OpenGL 没有提供着色器编译器，而是由**显卡驱动**来完成着色器的编译工作，也就是说，只要显卡驱动支持对 GLSL 的编译它就能运行，所以**能够跨平台**。而 DirectX 是由微软控制着色器的编译，就算用了不同的硬件，同一个着色器的编译也是一样，所以支持的平台只有微软自己的产品。

![](https://img-blog.csdnimg.cn/img_convert/788cdeb9b3280938a1b6e48c5de8b43d.png)

**OpenGL:** 一般它被认为是一个 API(Application Programming Interface, 应用程序编程接口)，包含了一系列可以操作图形、图像的函数。实际仅仅是由 Khronos 组织制定并维护的规范 (Specification)。  
OpenGL 规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现 (Implement) 的，将由 OpenGL 库的开发者自行决定。实际的 OpenGL 库的开发者通常是显卡的生产商。

**核心模式与立即渲染模式：**  
早期 OpenGL 使用立即渲染（Immediate mode, 也就是固定渲染管线）容易使用和理解，但是效率太低。从 OpenGL3.2 开始废弃立即渲染模式，鼓励使用核心模式（Core-profile)。  
核心模式：要求使用者真正理解 OpenGL 和图形编程，有一些难度，然而提供了更多的灵活性，更高的效率，可以更深入理解图形编程。

*   **扩展：**

OpenGL 的一大特性就是对扩展（Extension) 的支持，当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现。

*   **状态机：**

**OpenGL 自身是一个巨大的状态机 (State Machine)**：一系列的变量描述 OpenGL 此刻应当如何运行。OpenGL 的状态通常被称为 OpenGL 上下文 (Context)。我们通常使用如下途径去更改 OpenGL 状态：**设置选项，操作缓冲**。最后，我们使用当前 OpenGL 上下文来渲染。

![](https://img-blog.csdnimg.cn/img_convert/26094f341ccdacc0f3ccea0045321cfb.png)

*   **对象：**

**OpenGL 库是用 C 语言**写的，同时也支持多种语言的派生，但其**内核仍是一个 C 库**。由于 C 的一些语言结构不易被翻译到其它的高级语言，因此 OpenGL 开发的时候引入了一些抽象层。“对象 (Object)” 就是其中一个。  
使用对象的一个好处是在程序中，我们不止可以定义一个对象，并设置它们的选项，每个对象都可以是不同的设置。在我们执行一个使用 OpenGL 状态的操作的时候，只需要绑定含有需要的设置的对象即可。

*   **GLFW：**

GLFW 是一个专门针对 OpenGL 的 C 语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建 OpenGL 上下文，定义窗口参数以及**处理用户输入**。

*   **GLAD：**

GLAD 是用来管理 OpenGL 的函数指针的，所以在调用任何 OpenGL 的函数之前我们需要初始化 GLAD。

*   **视口 (Viewport):**

OpenGL 幕后使用 glViewport 中定义的位置和宽高进行 2D 坐标的转换，将 OpenGL 中的位置坐标转换为你的屏幕坐标。例如，OpenGL 中的坐标 (-0.5, 0.5) 有可能（最终）被映射为屏幕中的坐标 (200,450)。注意，处理过的 OpenGL 坐标范围只为 - 1 到 1，因此我们事实上将(-1 到 1) 范围内的坐标映射到 (0, 800) 和(0, 600)。

![](https://img-blog.csdnimg.cn/img_convert/ffcf9c1bf28658a53de6132fdb660257.png)

*   **双缓冲 (Double Buffer)**

应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们**交换 (Swap) 前缓冲和后缓冲**，这样图像就立即呈显出来，之前提到的不真实感就消除了。

**顶点数组对象：Vertex Array Object，VAO**  
**顶点缓冲对象：Vertex Buffer Object，VBO**  
**索引缓冲对象：Element Buffer Object，EBO 或 Index Buffer Object，IBO**

*   **图形渲染管线:**

在 OpenGL 中，任何事物都在 3D 空间中，而**屏幕和窗口却是 2D 像素数组**，这导致 OpenGL 的**大部分工作**都是关于把 **3D 坐标转**变为适应你**屏幕的 2D 像素**。3D 坐标转为 2D 坐标的处理过程是由 OpenGL 的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆**原始图形数据途经一个输送管道**，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的 **3D 坐标转换为 2D 坐标**，第二部分是把 **2D 坐标转变为实际的有颜色的像素**。这个教程里，我们会简单地讨论一下图形渲染管线，以及如何利用它创建一些漂亮的像素。

图形渲染管线接受**一组 3D 坐标**，然后把它们转变为你屏幕上的有色 2D 像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们**在 GPU 上为每一个（渲染管线）阶段运行各自的小程序**，从而在图形渲染管线中快速处理你的数据。这些小程序叫做**着色器 (Shader)**。

**OpenGL 着色器是用 OpenGL 着色器语言 (OpenGL Shading Language, GLSL) 写成的。**  
下面，你会看到一个图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分。

![](https://img-blog.csdnimg.cn/img_convert/380bb50a170dcc3111a00df68d4c9b80.png)

首先，我们以**数组的形式**传递 3 个 3D 坐标作为图形渲染管线**的输入**，用来表示一个三角形，这个数组叫做**顶点数据 (Vertex Data)**；顶点数据是一系列顶点的集合。一个顶点 (Vertex) 是一个 **3D 坐标的数据的集合**。而顶点数据是用顶点属性 (Vertex Attribute) 表示的，它可以包含任何我们想用的数据，我们还是假定每个顶点只由一个 **3D 位置和一些颜色值**组成的吧。  
为了让 OpenGL 知道我们的坐标和颜色值构成的到底是什么，OpenGL 需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的**点**？一系列的**三角形**？还是仅仅是一个**长长的线**？做出的这些提示叫做图元 (Primitive)，任何一个绘制指令的调用都将把图元传递给 OpenGL。这是其中的几个：**GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。**

**顶点着色器 -- 图元装配 -- 几何着色器 -- 光栅化 -- 片段着色器 -- 混合阶段**

图形渲染管线的第一个部分是**顶点着色器 (Vertex Shader)**，它把一个**单独的顶点作为输入**。顶点着色器主要的**目的是把 3D 坐标转为另一种 3D 坐标**，同时顶点着色器允许我们对顶点属性进行一些基本处理。

**图元装配 (Primitive Assembly) 阶段**将顶点着色器输出的所有顶点作为输入（如果是 GL_POINTS，那么就是一个顶点），并**将所有的点装配成指定图元的形状**

图元装配阶段的输出会传递给**几何着色器 (Geometry Shader)**。几何着色器把图元形式的一系列顶点的集合作为输入，它可以**通过产生新顶点构造出新的（或是其它的）图元来生成其他形状**。例子中，它**生成了另一个三角形**。

![](https://img-blog.csdnimg.cn/img_convert/e771b96c984bce52fa66a6b8831f885e.png)

![](https://img-blog.csdnimg.cn/img_convert/854449c43cf39979925b0d3db3a56510.png)

 **渲染一个三角形的过程**

![](https://img-blog.csdnimg.cn/img_convert/df277de5b7cfbcfb15b38dae6ef4020d.png)

几何着色器的输出会被传入**光栅化阶段 (Rasterization Stage)**，这里它会**把图元映射为最终屏幕上相应的像素，生成供片段着色器 (Fragment Shader) 使用的片段(Fragment)**。在片段着色器运行之前会执行裁切 (Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。（OpenGL 中的一个片段是 OpenGL 渲染一个像素所需的所有数据。）

**片段着色器**的主要**目的是计算一个像素的最终颜色**，这也是所有 OpenGL 高级效果产生的地方。通常，片段着色器包含 3D 场景的数据（**比如光照、阴影、光的颜色等等**），这些数据可以被用来计算最终像素的颜色。

在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做 **Alpha 测试和混合 (Blending) 阶段**。这个阶段**检测片段的对应的深度（和模板 (Stencil)）值，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃**。这个阶段也会检查 alpha 值（alpha 值定义了一个物体的透明度）并对物体进行混合 (Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。

*   **顶点输入**

开始绘制图形之前，我们必须先给 OpenGL 输入一些顶点数据。OpenGL 是一个 3D [图形库](https://so.csdn.net/so/search?q=%E5%9B%BE%E5%BD%A2%E5%BA%93&spm=1001.2101.3001.7020)，所以我们在 OpenGL 中指定的所有坐标都是 3D 坐标（x、y 和 z）。OpenGL 不是简单地把所有的 3D 坐标变换为屏幕上的 2D 像素；OpenGL 仅当 3D 坐标在 3 个轴（x、y 和 z）上都为 - 1.0 到 1.0 的范围内时才处理它。所有在所谓的标准化设备坐标 (Normalized Device Coordinates) 范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）

通常深度可以理解为 z 坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。

*   **标准化设备坐标 (Normalized Device Coordinates, NDC)**

一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个 x、y 和 z 值在 - 1.0 到 1.0 的一小段空间。

你的**标准化设备坐标**接着会**变换为屏幕空间坐标** (Screen-space Coordinates)，这是使用你通过 glViewport 函数提供的数据，进行**视口变换** (Viewport Transform) 完成的。所得的**屏幕空间坐标**又会被变换为片段输入到片段着色器中。

*   **顶点着色器：**

它会**在 GPU 上创建内存用于储存我们的顶点数据**，还要配置 OpenGL 如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。  
我们通过**顶点缓冲对象 (Vertex Buffer Objects, VBO) 管理这个内存**，它会在 GPU 内存（通常被称为显存）中储存大量顶点。  
顶点着色器 (Vertex Shader) 是几个可编程着色器中的一个。如果我们打算做渲染的话，现代 OpenGL 需要我们至少设置一个顶点和一个片段着色器。

*   **编译着色器**

我们已经写了一个顶点着色器源码（储存在一个 C 的字符串中），但是为了能够让 OpenGL 使用它，我们必须在运行时动态编译它的源码

*   **片段着色器**

片段着色器 (Fragment Shader) 是第二个也是最后一个我们打算创建的用于渲染三角形的着色器。片段着色器所做的是计算像素最后的颜色输出。

两个着色器现在都编译了，剩下的事情是把两个着色器对象链接到一个用来渲染的着色器程序 (Shader Program) 中

*   **着色器程序**

着色器程序对象 (Shader Program Object) 是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们链接 (Link) 为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。  
在把着色器对象链接到程序对象以后，记得删除着色器对象，  
我们已经把输入顶点数据发送给了 GPU，并指示了 GPU 如何在顶点和片段着色器中处理它。但还没结束，OpenGL 还不知道它该如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉 OpenGL 怎么做。

*   **链接顶点属性**

顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，它还的确意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。所以，我们必须在渲染前指定 OpenGL 该如何解释顶点数据。

*   **顶点数组对象**

**顶点数组对象** (Vertex Array Object, VAO) 可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个 VAO 中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的 VAO 就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的 VAO 就行了。刚刚设置的所有状态都将存储在 VAO 中

*   **流程：**

一个储存了我们顶点属性配置和应使用的 VBO 的顶点数组对象。一般当你打算绘制多个物体时，你首先要生成 / 配置所有的 VAO（和必须的 VBO 及属性指针)，然后储存它们供后面使用。当我们打算绘制物体的时候就拿出相应的 VAO，绑定它，绘制完物体后，再解绑 VAO。

![](https://img-blog.csdnimg.cn/img_convert/a27fbddbab1176f19711b20db5f9d4a2.png)

*   **索引缓冲对象：**

索引缓冲对象 (Element Buffer Object，EBO，也叫 Index Buffer Object，IBO)，只储存不同的顶点，并设定绘制这些顶点的顺序。和顶点缓冲对象一样，EBO 也是一个缓冲，它专门储存索引，OpenGL 调用这些顶点的索引来决定该绘制哪个顶点。

![](https://img-blog.csdnimg.cn/img_convert/940011b912e9af227d41a2c0c5b320be.png)

*   **着色器：**

**着色器 (Shader) 是运行在 GPU 上的小程序**。这些小程序为图形渲染管线的**某个特定部分而运行**。从基本意义上来说，**着色器只是一种把输入转化为输出的程序**。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间**唯一的沟通只有通过输入和输出**。

*   **GLSL：**

着色器是使用一种叫 GLSL 的类 C 语言写成的。GLSL 是为图形计算量身定制的，它包含一些**针对向量和矩阵操作**的有用特性。

着色器的开头总是要声明版本，接着是输入和输出变量、uniform 和 main 函数。每个着色器的入口点都是 main 函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。如果你不知道什么是 uniform 也不用担心，我们后面会进行讲解。

*   **数据类型：**

GLSL 中包含 C 等其它语言大部分的默认基础数据类型：int、float、double、uint 和 bool。GLSL 也有两种容器类型，它们会在这个教程中使用很多，分别是向量 (Vector) 和矩阵(Matrix)

1.  **vecn 包含 n 个 float 分量的默认向量**
2.  **bvecn 包含 n 个 bool 分量的向量**
3.  **ivecn 包含 n 个 int 分量的向量**
4.  **uvecn 包含 n 个 unsigned int 分量的向量**
5.  **dvecn 包含 n 个 double 分量的向量**

可以分别使用**.x、.y、.z 和. w** 来获取它们的第 1、2、3、4 个分量。GLSL 也允许你对颜色使用 **rgba**，或是对纹理坐标使用 **stpq** 访问相同的分量。

*   **输入与输出：**

虽然着色器是各自独立的小程序，但是它们都是一个整体的一部分，出于这样的原因，我们希望每个着色器都有输入和输出，这样才能进行数据交流和传递。GLSL 定义了 in 和 out 关键字专门来实现这个目的。

*   **Uniform：**

Uniform 是一种从 CPU 中的应用向 GPU 中的着色器发送数据的方式，但 uniform 和顶点属性有些不同。首先，uniform 是**全局的 (Global)**。全局意味着 uniform 变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把 uniform 值设置成什么，**uniform 会一直保存它们的数据，直到它们被重置或更新**。（可以设置颜色随时间变化）

*   **更多属性：**

我们了解了如何填充 VBO、配置顶点属性指针以及如何把它们都储存到一个 VAO 里。这次，我们同样打算把颜色数据加进顶点数据中。我们将把颜色数据添加为 3 个 float 值至 vertices 数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色：  
float vertices[] = {  
// 位置 // 颜色  
0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, // 右下  
-0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, // 左下  
0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f // 顶部  
};

*   **纹理：**

为了能够把纹理映射 (Map) 到三角形上，我们需要**指定三角形的每个顶点各自对应纹理的哪个部分**。这样每个顶点就会关联着一个纹理坐标 (Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值 (Fragment Interpolation)。  
**纹理坐标在 x 和 y 轴**上，**范围为 0 到 1 之间**（注意我们使用的是 2D 纹理图像）。使用纹理坐标获取纹理颜色叫做采样 (Sampling)。**纹理坐标起始于 (0, 0)，也就是纹理图片的左下角，终始于 (1, 1)，即纹理图片的右上角**。

*   **纹理过滤：**

纹理坐标不依赖于分辨率 (Resolution)，它可以是任意浮点值，所以 OpenGL 需要知道怎样将纹理像素(Texture Pixel，也叫 Texel，译注 1) 映射到纹理坐标。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。你可能已经猜到了，OpenGL 也有对于纹理过滤 (Texture Filtering) 的选项。纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：**GL_NEAREST 和 GL_LINEAR。**

1.  **GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）**是 OpenGL 默认的纹理过滤方式。当设置为 GL_NEAREST 的时候，OpenGL 会选择中心点最接近纹理坐标的那个像素。
2.  **GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）**它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。

**GL_NEAREST 产生了颗粒状的图案**，我们能够清晰看到**组成纹理的像素**，而 GL_LINEAR 能够**产生更平滑的图案**，很难看出单个的纹理像素。GL_LINEAR 可以产生更真实的输出，但有些开发者更喜欢 8-bit 风格，所以他们会用 GL_NEAREST 选项。

*   **多级渐远纹理:**

想象一下，假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL 从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。  
OpenGL 使用一种叫做**多级渐远纹理 (Mipmap)** 的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL 会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。