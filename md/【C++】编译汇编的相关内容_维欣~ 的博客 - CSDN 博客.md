> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/qq_43411373/article/details/105747878)

一、操作系统
------

1、操作系统分为 32 位和 64 [位操作](https://so.csdn.net/so/search?q=%E4%BD%8D%E6%93%8D%E4%BD%9C&spm=1001.2101.3001.7020)系统。（其中 **32 位和 64 位表示的是算术逻辑单元的宽度**）  
2、举例：

```
int a = 10;
&a;
```

其中 & a 代表的是**虚拟地址，目的是为了保护内存**。原因如下：  
假如有两个程序 A 和程序 B  
![](https://img-blog.csdnimg.cn/20200425124152262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDExMzcz,size_16,color_FFFFFF,t_70)

（1）A 程序和真实的物理地址内存之间有一个 4G 的[虚拟内存](https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020)地址，A 程序会映射到虚拟地址空间，再由虚拟地址空间映射到一部分物理地址内存上，**如果 A 程序被破坏，因为有虚拟地址的保护，不会直接破坏真实的物理地址**。  
（2）如果虚拟地址发生偏移，映射到 A 程序的虚拟[地址空间](https://so.csdn.net/so/search?q=%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4&spm=1001.2101.3001.7020)上，在映射到 A 程序的真实物理地址上，也就是说**如果发生偏移，它只会在自己的部分进行偏移，不会影响到 B 程序**。

### 3、虚拟地址内存的布局

Linux 下，用户空间和内核空间是 1：3 存放，而 Windows 下是 2：2 存放的。  
![](https://img-blog.csdnimg.cn/20200425135619127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDExMzcz,size_16,color_FFFFFF,t_70)

（1）**保留区**：不可的访问（不可读也不可写）

```
int *p = NULL;
*p = 20;//error①  p在保留区，不可写
*p;//error②  p在保留区，不可读
```

（2）**.data 段和. bss 段都是数据段**，.data 段存放的是已初始化且初始化不为 0 的数据，.bss 段存放的是未初始化或初始化为 0 的数据。  
（3）**stack（栈区）和 heap（堆区）**上存储数据的变量，stack 栈是由高地址向低地址开辟，而 heap 是由低地址向高地址开辟。  
（4）在 Linux 下来说，main() 函数中还有形参，mian() 函数的原型是`int main(int argc, char *argv[]);`而它的形参是由**命令行参数**传递的。  
（5）如果给出一个头文件`#include<stdio.h>`，头文件是在预编译阶段处理，而且将头文件内容直接展示在源文件下，所以这个头文件的路经是在库文件的**环境变量**中。  
（6）头文件中放的都是函数的声明，函数的实现是在源文件中，而源文件都是以**共享库**的方式加载到程序中。  
（7）**ZONE DMA 为直接内存访问区**，CPU 来运行指令，而指令是在内存中存放，因为 CPU 和内存的效率不同，所以中间由寄存器来过渡数据。而 DMA 的作用就是让 CPU 直接来取数据，不用过寄存器。  
（8）**ZONE_NORMAL 为内存使用区**，存放内存关系。对于程序最终都是要映射到物理内存上，而所有的页面映射都存放在内存使用区。  
（9）**ZONE_HIGHMEN** 主要用来映射大于 1G 的文件，如果文件大于 1G，就不能直接存放在内存中，就要用 ZONE_HIGHMEN 来做大文件映射。这是对于 32 位操作系统下的，而对于 64 位操作系统下，完全可以直接加载到内存上，用不到 ZONE_HIGHMEN。

二、编译的过程
-------

也就是 .cpp 的源文件到 .exe 可执行的二进制文件的过程  
**（1）预编译**  
①处理文件中的`#define`，将它删掉，再将后面的内容进行替换。  
②删掉`#if`和`#endif`。  
③将所有的`#include`的头文件打开，将其中的内容递归展开（因为在一个头文件中有可能还包含着其他头文件）。  
④删除文件中的所有注释。  
⑤添加行号和文件标识，保证编译阶段出错后能够准确的找到位置。  
⑥保留`#pragma`，它是由编译阶段处理的指令  
**生成 .i 文件**  
**（2）编译**  
①词法分析  
②语法分析  
③语义分析  
④代码优化  
⑤生成汇编指令  
**生成 .s 文件**  
**（3）汇编**  
①翻译指令，将编译生成的汇编指令全部翻译成二进制指令。  
**生成 .o 文件，也可称为目标文件**  
**（4）链接**  
将所有目标文件整合成一个可执行文件，形成最终的 .o 文件或者 .obj 文件（Windows 中）  
主要是处理全局符号，因为局部符号在编译阶段就能看见  
**①合并段和符号表**（最终合成为一个 .text 段、 .data 段和. bss 段），符号表合成后就能对弱符号进行处理。  
**②符号解析**  
从符号引用的地方找到符号定义的地方，也就是删去`*UND*` 以及处理弱符号  
**③分配地址和空间**  
**④符号重定位**  
把指令段中虚假的地址和偏移进行替换  
**（5）运行**  
让程序变成进程  
**①建立虚拟地址空间和物理内存的映射，分配页目录和页表，即创建内核映射结构体（PCB）**  
**②加载指令段和数据段**  
**③将程序入口地址写入下一行指令寄存器**，CPU 就可以直接从下一行指令寄存器中取。  
CPU 来运行指令，而指令是在内存中存放，因为 CPU 和内存的效率不同，所以中间由寄存器来过渡数据，在寄存器从内存中取一条指令，在由 CPU 从寄存器中取走，在 CPU 处理第一条指令的时候，寄存器又在内存中取下一条指令，所以寄存器又称为下一行指令寄存器。

三、汇编后未处理的问题
-----------

### 1、弱符号问题

**text.c**

```
int a;//弱符号
void seta()
{
	a = 30;
}
```

**main.c**

```
short a = 10;
short b = 20;
int main()
{
	seta();
	printf("a:%d\nb:%d\n",a,b);
	return 0;
}
```

运行结果为  
a = 30  
b = 0  
原因如下：  
（1）在 C 语言中有强弱符号的区分  
强符号是已初始化的符号；弱符号是未初始化的符号。  
（2）强弱符号的规则：  
①两个强符号，报错  
②一强一弱，选强符号  
③两个弱符号，根据编译器而定  
（3）上面的程序在进行 text.c 时，处于编译阶段，已经选定了指令，则在 main.c 的运行阶段是不会改变的，所以在编译阶段 a 是 int 类型，a = 30，但在 main.c 阶段时 a 为 short 类型，并且为强符号，所以就是给 short a 赋值 30，就会出现越界，越界的内容就会存放在 short b 中，因为 b 中有数据，所以程序也不会出现报错，但是这样就会使程序的结果出错，这就是汇编后遗留下来的问题，对弱符号的处理。  
![](https://img-blog.csdnimg.cn/20200425195349968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDExMzcz,size_16,color_FFFFFF,t_70)

### 2、符号表

如果有外部符号存在，我们不知道外部符号在什么位置定义的，就会先放在 `*UND*` 中。

### 3、指令段

在指令段中，外部的符号地址未知时，就先给出一个虚假的地址存放；外部的函数地址调用时，不知道函数调用的地址，就会先给出偏移。